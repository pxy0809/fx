# 组件开发规范

## 组件定义

组件（Component）是对数据和方法的简单封装。组件可以有自己的属性和方法。属性是组件数据的简单访问者。方法则是组件的一些简单而可见的功能([百科](https://baike.baidu.com/item/%E7%BB%84%E4%BB%B6/6902128?fr=aladdin))。

组件是一个具有独立的逻辑和功能或界面，同时又能根据规定的接口规则进行相互融化，变成一个完整的应用。

在前端领域，组件自由组合形成功能完整的界面，当不需要某个组件，或者想要替换某个组件时，可以随时进行替换和删除，而不影响整个应用的运行。前端组件化的核心思想就是将一个巨大复杂的东西拆分成粒度合理的小东西。

注：组件化是从产品功能角度进行分割，模块化是从代码实现角度进行分割，模块化是组件化的前提和基础。

## 组件化的好处

- 提高开发效率
- 方便重复使用
- 简化调试步骤
- 提升整个项目的可维护性
- 便于协同开发
- 使其高内聚，低耦合，达到分治与复用的目的

## 组件命名规范

命名可遵循以下规则：

1. 有意义的名词、简短、具有可读性
2. 以小写开头，采用短横线分割命名
3. 文件夹命名主要以功能模块代表命名
4. 符合自定义元素规范: 使用连字符分隔单词，切勿使用保留字

## 模块化规范

历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。

在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。

ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。

详细请参考[阮一峰：ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/module)。

## 开发语言

[Typescript](https://www.tslang.cn/) 是 JavaScript 的超集。它可以编译成纯 JavaScript 。TypeScript 可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。

TypeScript 从今天数以百万计的 JavaScript 开发者所熟悉的语法和语义开始。使用现有的 JavaScript 代码，包括流行的 JavaScript 库，并从 JavaScript 代码中调用 TypeScript 代码。

TypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript引擎中。

TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。

这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的 JavaScript。在开发基础组件时，强烈推荐使用（业务组件或依赖其他框架组件除外）。

## 构建规范

如果你将项目拆分成小的单独文件中，这样开发软件通常会很简单，因为这通常会消除无法预知的相互影响(remove unexpected interaction)，以及显著降低了所要解决的问题的复杂度(complexity of the problem)，并且可以在项目最初时，就简洁地编写小的项目（不一定是标准答案）。不幸的是，JavaScript 以往并没有将此功能作为语言的核心功能。

Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。Rollup 对代码模块使用新的标准化格式，这些标准都包含在 JavaScript 的 ES6 版本中，而不是以前的特殊解决方案，如 CommonJS 和 AMD。

ES6 模块可以使你自由、无缝地使用你最喜爱的 library 中那些最有用独立函数，而你的项目不必携带其他未使用的代码。

除了使用 ES6 模块之外，Rollup 还静态分析代码中的 import，并将排除任何未实际使用的代码。这允许您架构于现有工具和模块之上，而不会增加额外的依赖或使项目的大小膨胀。

Rollup 只引入最基本最精简代码，所以可以生成轻量、快速，以及低复杂度的 library 和应用程序。因为这种基于显式的 import 和 export 语句的方式，它远比「在编译后的输出代码中，简单地运行自动 minifier 检测未使用的变量」更有效。

## 编码规范

优秀的项目源码，即使是多人开发，看代码也如出一人之手。统一的编码规范，可使代码更易于阅读，易于理解，易于维护。尽量按照 [ESLint](https://cn.eslint.org/) 格式要求编写代码。

## 单元测试

长期以来，前端开发的单元测试并不是在前端的开发过程中所必须的，也不是每个前端开发工程师所注意和重视的，甚至扩大到软件开发过程中单元测试这一环也不是在章程上有书面规定所要求的。但是随着每个工程的复杂化、代码的高复用性要求和前端代码模块之间的高内聚低耦合的需求，前端工程中的单元测试流程就显得很有其必要。

### Mocha

Mocha（发音"摩卡"）诞生于2011年，是现在最流行的JavaScript测试框架之一，在浏览器和Node环境都可以使用。所谓"测试框架"，就是运行测试的工具。通过它，可以为 JavaScript 应用添加测试，从而保证代码的质量。

详细使用文档，请参考[mocha 官网](http://www.mochajs.org/)。

### 断言库

所谓"断言"，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。所有的测试用例都应该含有一句或多句的断言。它是编写测试用例的关键。断言功能由断言库来实现，Mocha 本身不带断言库，所以必须先引入断言库。

[chai](https://www.chaijs.com/) 是一套 TDD(测试驱动开发)/ BDD(行为驱动开发)的断言库。包含有 3 个断言库支持 BDD 风格的 `expect/should` 和 TDD 风格的 `assert`,这里主要说明 `expect/should` 库,BDD 风格说简单的就是你的测试代码更加的语义化,让你的断言可读性更好, `expect/should` 库都支持链式调用可以在 Node 和浏览器环境运行，可以高效的和任何js测试框架搭配使用。

### 测试报告

[Mochawesome](http://adamgruber.github.io/mochawesome/) 是 Mocha 自定义测试报告组件。简洁、干净、现代的设计，支持测试和套件嵌套，内联检查测试代码，失败测试的堆栈跟踪，支持向测试中添加上下文信息，只显示所需测试的筛选器，响应迅速，移动友好，离线查看，支持IE9+。

### 覆盖率

覆盖率用于评估在代码测试的过程中，所测试的代码的比例和程度。通常而言，测试覆盖率高的代码出错的几率比较小；测试覆盖率较低的代码出现不可预知行为的几率比较大。

根据维基百科的资料，基本的代码覆盖率有 4 种：

- `函数覆盖率`：程序中的函数占函数总量的比重；
- `语句覆盖率`：执行代码行数占代码总行数的比重；
- `分支覆盖率`：表示代码逻辑的每个分支是否都测试，比如 if 条件为 true 或者 false 时的代码是否都被执行；
- `条件覆盖率`：每个布尔子表达式都应该被赋值为 true 或者 false，这样才满足条件覆盖率测试。

[Istanbul](https://istanbul.js.org/) 是 JavaScript 程序的代码覆盖率工具，以土耳其最大城市伊斯坦布尔命名。Istanbul 会对代码进行转换，生成语法树，然后在相应位置注入统计代码，执行之后根据注入的全局变量的值，统计代码执行的次数；

## 结构化规范

```
|- component
  |- coverage # 单元测试覆盖率
  |- dist  # 构建产物
  |- report # 单元测试报告   
  |- src  # 源码
  |- test  # 测试脚本
  |- .eslintrc.js  # eslint 配置信息
  |- .gitignore  # Git 提交忽略文件
  |- package.json  # npm 依赖包信息
  |- rollup.config.js  # Rollup 构建配置
  |_ README.md  # 组件功能、API和更新历史描述信息
```

### 安装依赖

在项目根目录执行 `npm install` 命令安装所有依赖关系。

### 构建命令

- `npm run build`: 对当前项目进行构建，并将构建产物输出到 `dist` 文件夹；
- `npm run test`: 使用 `mocha` 对代码进行单元测试；
- `npm run test:coverage`: 使用 `Istanbul` 进行代码覆盖率测试。